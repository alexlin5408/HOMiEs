#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <unordered_map>
#include <cctype>
#include <regex>
#include <chrono>


using namespace std;


class Homes_Sorter {
private:
    unordered_map<string, vector<string>> dataset;
    float min_acres = 0.00;
    float max_acres = 0.00;
    int max_homesize = 0;
    int min_homesize = 0;
    int max_price = 0;
    int bed_min = 0;
    int bed_max = 0;
    float bathroom_min = 0.0;
    float bathroom_max = 0.0;
    int bed_importance = 0;
    int bathroom_importance = 0;
    int homesize_Importance = 0;
    int acre_importance = 0;
    int price_importance = 0;
    bool valid_homesize_min = false;
    bool valid_homesize_max = false;
    bool valid_max_price = false;
    bool valid_acre_min = false;
    bool valid_acre_max = false;
    bool valid_state = false;
    bool valid_bath_min = false;
    bool valid_bath_max = false;
    bool valid_bed_min = false;
    bool valid_bed_max = false;
    bool valid_bed_importance = false;
    bool valid_bathroom_importance = false;
    bool valid_homesize_importance = false;
    bool valid_acre_importance = false;
    bool valid_price_importance = false;
    string State;
    string city;
    vector<string> quick_rankings;
    vector<string> merge_rankings;
    long long time_merge;
    long long time_quick;

public:
    void user_preference() {
        static const regex tester("^[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?$");
        while (valid_state == false) {
            cout << "Available States: Pennsylvania, New Jersey, New York" << endl;
            cout << "Enter a State: ";
            getline(std::cin, State);
            if (State == "Pennsylvania" || State == "New Jersey" || State == "New York") {
                valid_state = true;
            } else {
                cout << "Invalid State" << endl;
            }
        }
        while (valid_bath_min == false) {
            cout << "Mininum number of bathrooms: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                bathroom_min = stod(temp);
                valid_bath_min = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_bath_max == false) {
            cout << "Maximum number of bathrooms: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                bathroom_max = stod(temp);
                if (bathroom_max >= bathroom_min) {
                    valid_bath_max = true;
                } else {
                    cout << "Invalid Input. Max number of bathrooms has to be bigger than or equal to the minimum."
                         << endl;
                }
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_bed_min == false) {
            cout << "Mininum number of bedrooms: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                bed_min = stoi(temp);
                valid_bed_min = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_bed_max == false) {
            cout << "Maximum number of bedrooms: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                bed_max = stoi(temp);
                if (bed_max >= bed_min) {
                    valid_bed_max = true;
                } else {
                    cout << "Invalid Input. Max number of bedrooms has to be bigger than or equal to the minimum."
                         << endl;
                }
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_acre_min == false) {
            cout << "Mininum acreage: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                min_acres = stod(temp);
                valid_acre_min = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_acre_max == false) {
            cout << "Maximum acreage: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                max_acres = stod(temp);
                if (max_acres >= min_acres) {
                    valid_acre_max = true;
                } else {
                    cout << "Invalid Input. Max acreage must be greater than or equal to the minimum." << endl;
                }
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_homesize_min == false) {
            cout << "Minimum square footage of house (In Square feet): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                min_homesize = stoi(temp);
                valid_homesize_min = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_homesize_max == false) {
            cout << "Maximum square footage of house (In Square feet): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                max_homesize = stod(temp);
                if (max_homesize >= min_homesize) {
                    valid_homesize_max = true;
                } else {
                    cout
                            << "Invalid Input. Max square footage of the house must be greater than or equal to the minimum."
                            << endl;
                }
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_max_price == false) {
            cout << "Maximum price: ";
            string temp;
            cin >> temp;
            if (regex_match(temp, tester) == true) {
                max_price = stoi(temp);
                valid_max_price = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        static const regex importance_tester("^(10|[1-9])$");
        while (valid_bathroom_importance == false) {
            cout << "How important is having more bathrooms? (Enter a number 1-10): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, importance_tester) == true) {
                bathroom_importance = stoi(temp);
                valid_bathroom_importance = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_bed_importance == false) {
            cout << "How important is having more bedrooms? (Enter a number 1-10): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, importance_tester) == true) {
                bed_importance = stoi(temp);
                valid_bed_importance = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_acre_importance == false) {
            cout << "How important is having more acres? (Enter a number 1-10): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, importance_tester) == true) {
                acre_importance = stoi(temp);
                valid_acre_importance = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_homesize_importance == false) {
            cout << "How important is having a larger home size (In square foot)? (Enter a number 1-10): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, importance_tester) == true) {
                homesize_Importance = stoi(temp);
                valid_homesize_importance = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
        while (valid_price_importance == false) {
            cout << "How important is having a lower price? (Enter a number 1-10): ";
            string temp;
            cin >> temp;
            if (regex_match(temp, importance_tester) == true) {
                price_importance = stoi(temp);
                valid_price_importance = true;
            } else {
                cout << "Invalid Input" << endl;
            }
        }
    }

    void insert(string state_string, string city_string, string num_bathrooms_string, string num_bedrooms_string,
                string acres_string, string house_size_string, string price_string, int temp_counter) {
        if (state_string != State) {
            return;
        }
        if (stod(num_bathrooms_string) > bathroom_max || stod(num_bathrooms_string) < bathroom_min) {
            return;
        }
        if (stoi(num_bedrooms_string) > bed_max || stoi(num_bedrooms_string) < bed_min) {
            return;
        }
        if (stod(acres_string) > max_acres || stod(acres_string) < min_acres) {
            return;

        }
        if (stoi(house_size_string) > max_homesize || stoi(house_size_string) < min_homesize) {
            return;
        }
        if (stoi(price_string) > max_price) {
            return;
        }
        int bath_score = 0;
        int bed_score = 0;
        int acreage_score = 0;
        int feet_score = 0;
        int price_score = 0;
        bath_score = (stod(num_bathrooms_string) / bathroom_max) * 10;
        if (bath_score == 0) {
            bath_score = 1;
        }
        bed_score = (stod(num_bedrooms_string) / bed_max) * 10;
        if (bed_score == 0) {
            bed_score = 1;
        }
        acreage_score = (stod(acres_string) / max_acres) * 10;
        if (acreage_score == 0) {
            acreage_score = 1;
        }
        feet_score = (stod(house_size_string) / max_homesize) * 10;
        if (feet_score == 0) {
            feet_score = 1;
        }
        price_score = 10 - ((stod(price_string) / max_price) * 10);
        if (price_score == 0) {
            price_score = 1;
        }
        bed_score = bed_score * bed_importance;
        bath_score = bath_score * bathroom_importance;
        acreage_score = acreage_score * acre_importance;
        feet_score = feet_score * homesize_Importance;
        price_score = price_score * price_importance;
        int total_currentScore = 0;
        total_currentScore = bed_score + bath_score + acreage_score + feet_score + price_score;
        string current_house_name = "House " + to_string(temp_counter);
        vector<string> home_attributes; //Order is: Home score, Price, State, City, Num of Beds, Num of Baths, Acres, and home size.
        home_attributes.push_back(to_string(total_currentScore));
        home_attributes.push_back(price_string);
        home_attributes.push_back(state_string);
        home_attributes.push_back(city_string);
        home_attributes.push_back(num_bedrooms_string);
        home_attributes.push_back(num_bathrooms_string);
        home_attributes.push_back(acres_string);
        home_attributes.push_back(house_size_string);
        dataset[current_house_name] = home_attributes;
    }

    vector<string> quicksort()
    //function that places dataset in vector then calls quick sort function
    //While also keeping track of time it take for quicksort to occur
    {
        vector<string> houses;
        for (auto itr = dataset.begin(); itr != dataset.end(); itr++) {
            houses.push_back(itr->first);
        }
        if (houses.size() <= 1) //not enough houses to sort
        {
            time_quick = 0;
            quick_rankings = houses;
        } else {
            auto start_time = chrono::high_resolution_clock::now();
            quicksort_helper(houses, 0, houses.size() - 1);
            auto end_time = chrono::high_resolution_clock::now();
            auto duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time).count();
            time_quick = duration;
            quick_rankings = houses;
            cout << "Time taken by the function: " << duration << " microseconds" << endl;
        }
        return houses;
    }

    void quicksort_helper(vector<string> &houses, int left, int right)
    //function that recusivly call quicksort_helper until left value is less than right ie: sorted
    {
        if (left < right) {
            int p = partition(houses, left, right);
            quicksort_helper(houses, left, p - 1); //sort left of pivot
            quicksort_helper(houses, p + 1, right); //sort right of pivot
        }
    }

    int partition(vector<string> &houses, int left, int right)
    //function that takes vectors and swaps houses based off value compare to pivot
    {
        string pivot = houses[left]; //set pivot to the first element of the vector
        int up = left;
        int down = right;
        while (up < down) //sort around the pivot
        {
            while (up < right && stoi(dataset[houses[up]][0]) >= stoi(dataset[pivot][0])) {
                up++;
            }
            while (down > left && stoi(dataset[houses[down]][0]) <= stoi(dataset[pivot][0])) {
                down--;
            }
            if (up < down) {
                swap(houses, up, down);
            }
        }
        swap(houses, left, down);
        return down;
    }

    void swap(vector<string> &houses, int left, int right)
    //Swaps the postion of the houses at left and right index
    {
        string temp = houses[right];
        houses[right] = houses[left];
        houses[left] = temp;
    }


    vector<string> MergeSort()
    //function that places values in a vector then call merge sort for that vector.
    // While also taking the time for merge sort function to occur
    {
        vector<string> merge_sort_vector;
        for (auto it = dataset.begin(); it != dataset.end(); ++it) {
            merge_sort_vector.push_back(it->first);
        }

        if (merge_sort_vector.size() <= 1) //not enough houses to sort
        {
            time_merge = 0;
            merge_rankings = merge_sort_vector;
        } else {
            auto start_time = chrono::high_resolution_clock::now();
            MergeSortFunction(dataset, merge_sort_vector, 0, merge_sort_vector.size() - 1);
            auto end_time = chrono::high_resolution_clock::now();
            auto duration = chrono::duration_cast<chrono::microseconds>(end_time - start_time).count();
            time_merge = duration;
            cout << "Time taken by the function: " << duration << " microseconds" << endl;
        }
        merge_rankings = merge_sort_vector;
        return merge_rankings;
    }

    void MergeSortFunction(unordered_map<string, vector<string>> &DataSetMap, vector<string> &DataSetVector, int left,
                           int right)
    //function that recusively  call mergesort until left value is less than right ie: sorted
    {
        if (left < right) {
            int mid = left + (right - left) / 2;

            MergeSortFunction(DataSetMap, DataSetVector, left, mid);
            MergeSortFunction(DataSetMap, DataSetVector, mid + 1, right);

            HelperMerge(DataSetMap, DataSetVector, left, mid, right);
        }
    }

    void
    HelperMerge(unordered_map<string, vector<string>> &DataSetMap, vector<string> &Houses, int left, int mid, int right)
    //Function that performs the merge sort by comparing values and moving location of data based off of comparison
    {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        vector<string> leftVect(Houses.begin() + left, Houses.begin() + left + n1);
        vector<string> rightVect(Houses.begin() + mid + 1, Houses.begin() + mid + 1 + n2);

        int i = 0;
        int j = 0;
        int k = left;

        while (i < n1 && j < n2) {
            if (compareHouses(DataSetMap, leftVect[i], rightVect[j])) {
                Houses[k++] = leftVect[i++];
            } else {
                Houses[k++] = rightVect[j++];
            }
        }

        while (i < n1) {
            Houses[k++] = leftVect[i++];
        }

        while (j < n2) {
            Houses[k++] = rightVect[j++];
        }


    }

    bool compareHouses(unordered_map<string, vector<string>> &DataSetMap, string &house1, string &house2)
    //function to compare houses first based off score then based off price if scores are equal
    {

        int score1value;
        int score2value;
        int price1value;
        int price2value;

        string score1 = DataSetMap[house1][0];
        score1value = stoi(score1);
        string price1 = DataSetMap[house1][1];;
        price1value = stoi(price1);

        string score2 = DataSetMap[house2][0];
        score2value = stoi(score2);
        string price2 = DataSetMap[house2][1];;
        price2value = stoi(price2);


        if (score1value > score2value) {
            return true;
        } else if (score1value < score2value) {
            return false;
        } else {
            if (price1value < price2value) {
                return true;
            } else {
                return false;
            }
        }
    }

    bool compare_results()
    //function to checks if the results from merge and quick sort are the same
    {
        for (int i = 0; i < 3; i++) {
            if (stoi(dataset[merge_rankings[i]][0]) != stoi(dataset[quick_rankings[i]][0])) {
                return false;
            } else if (stoi(dataset[merge_rankings[i]][1]) != stoi(dataset[quick_rankings[i]][1])) {
                return false;
            } else {
                return true;
            }
        }
    }
};

int main(){
    Homes_Sorter T;
    T.user_preference();
    fstream file("Files/DataSet.csv");
    string line;
    int temp_counter = 0;
    while ((getline(file,line)))
    {
        temp_counter += 1;
        string num_bedrooms_string, num_bathrooms_string, acres_string, city_string, state_string, house_size_string, price_string;
        stringstream str(line);
        getline(str, num_bedrooms_string, ',');
        getline(str, num_bathrooms_string, ',');
        getline(str, acres_string, ',');
        getline(str, city_string, ',');
        getline(str, state_string, ',');
        getline(str, house_size_string, ',');
        str >> price_string;

        if (num_bathrooms_string == "") {
            num_bathrooms_string = "0.0";
        }
        if (num_bedrooms_string == "") {
            num_bedrooms_string = "0";
        }
        if (acres_string == "") {
            acres_string = "0.00";
        }
        if (house_size_string == "") {
            house_size_string = "0";
        }
        T.insert(state_string, city_string,num_bathrooms_string, num_bedrooms_string, acres_string,house_size_string, price_string,temp_counter);
    }
    T.MergeSort();
    T.quicksort();
    if (T.compare_results())
    {
        cout << "yippee!" << endl;
    }
    return 0;
}
